// This is a psuedo-random number generator; outputs will always be the same number
// given the same ctx (transaction context). Note that the ctx is mutated every time a
// number is generated, so it can be used consecutively in the same transaction, however
// the sequence of random numbers is deterministic.
//
// I don't know of any way for a user to externally "game" this; I believe the UID's
// generated by Sui are very dependent upon the chain itself.
//
// Eventually this should be replaced by a VRF from Switchboard (work in progress)

module sui_utils::rand {
    use std::hash;
    use std::vector;

    use sui::bcs;
    use sui::object;
    use sui::clock::{Self, Clock};
    use sui::tx_context::{Self, TxContext};

    use sui_utils::counter::{Self, Counter};

    const EBAD_RANGE: u64 = 0;
    const ETOO_FEW_BYTES: u64 = 1;
    const EDIVISOR_MUST_BE_NON_ZERO: u64 = 2;

    public fun rng(min: u64, max: u64, ctx: &mut TxContext): u64 {
        assert!(max >= min, EBAD_RANGE);
        let value = from_seed(seed(ctx));

        value % (max - min) + min
    }

    public fun rng_with_clock(min: u64, max: u64, clock: &Clock, ctx: &mut TxContext): u64 {
        assert!(max > min, EBAD_RANGE);
        let value = from_seed(seed_with_clock(clock, ctx));

        value % (max - min) + min
    }

    public fun rng_with_counter<T>(
        w: &T,
        min: u64,
        max: u64,
        counter: &mut Counter<T>,
        ctx: &mut TxContext
    ): u64 {
        assert!(max > min, EBAD_RANGE);
        let value = from_seed(seed_with_counter(w, counter, ctx));

        value % (max - min) + min
    }

    public fun rng_with_clock_and_counter<T>(
        w: &T,
        min: u64,
        max: u64,
        clock: &Clock,
        counter: &mut Counter<T>,
        ctx: &mut TxContext
    ): u64 {
        assert!(max > min, EBAD_RANGE);

        let value = from_seed(seed_with_clock_and_counter(w, clock, counter, ctx));

        value % (max - min) + min
    }

    public fun from_seed(seed: vector<u8>): u64 {
        assert!(vector::length(&seed) >= 8, ETOO_FEW_BYTES);
        bcs::peel_u64(&mut bcs::new(seed))
    }

    // generates seed using the tx context (epoch, sender and a newly created uid) and clock 
    public fun seed_with_clock(clock: &Clock, ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);

        let timestamp_bytes = bcs::to_bytes(&clock::timestamp_ms(clock));
        vector::append(&mut raw_seed, timestamp_bytes);

        hash::sha3_256(raw_seed)
    }

    // generates seed using the tx context (epoch, sender and a newly created uid) and a counter 
    public fun seed_with_counter<T>(w: &T, counter: &mut Counter<T>, ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);

        let counter_bytes = bcs::to_bytes(&counter::increment(counter, w));
        vector::append(&mut raw_seed, counter_bytes);

        hash::sha3_256(raw_seed)
    }

    // generates seed using the tx context (epoch, sender and a newly created uid) and clock 
    public fun seed_with_clock_and_counter<T>(w: &T, clock: &Clock, counter: &mut Counter<T>, ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);

        let timestamp_bytes = bcs::to_bytes(&clock::timestamp_ms(clock));
        let counter_bytes = bcs::to_bytes(&counter::increment(counter, w));

        vector::append(&mut raw_seed, timestamp_bytes);
        vector::append(&mut raw_seed, counter_bytes);

        hash::sha3_256(raw_seed)
    }

    // generates seed using the tx context (epoch, sender and a newly created uid)
    public fun seed(ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);
        hash::sha3_256(raw_seed)
    }

    public fun raw_seed(ctx: &mut TxContext): vector<u8> {
        let sender = tx_context::sender(ctx);
        let sender_bytes = bcs::to_bytes(&sender);

        let epoch = tx_context::epoch(ctx);
        let epoch_bytes = bcs::to_bytes(&epoch);

        let id = object::new(ctx);
        let id_bytes = object::uid_to_bytes(&id);
        object::delete(id);

        let raw_seed = vector::empty<u8>();
        vector::append(&mut raw_seed, id_bytes);
        vector::append(&mut raw_seed, epoch_bytes);
        vector::append(&mut raw_seed, sender_bytes);

        raw_seed
    }
}

#[test_only]
module sui_utils::rand_tests {
    use sui::test_scenario;
    use sui::tx_context::TxContext;
    use sui::clock::{Self, Clock};

    use sui_utils::rand;

    const EOUTSIDE_RANGE: u64 = 0;
    const EBAD_SINGLE_RANGE: u64 = 1;
    const EONE_IN_A_MILLION_ERROR: u64 = 2;

    public fun print_rand(min: u64, max: u64, ctx: &mut TxContext): u64 {
        let num = rand::rng(min, max, ctx);
        // std::debug::print(&num);
        assert!(num >= min && num < max, EOUTSIDE_RANGE);
        num
    }

    public fun print_rand_with_clock(min: u64, max: u64, clock: &Clock, ctx: &mut TxContext): u64 {
        let num = rand::rng_with_clock(min, max, clock, ctx);
        // std::debug::print(&num);
        assert!(num >= min && num < max, EOUTSIDE_RANGE);
        num
    }

    #[test]
    public fun test1() {
        // 1st tx: must always be == 1
        let scenario = test_scenario::begin(@0x5);
        print_rand(1, 2, test_scenario::ctx(&mut scenario));

        // 2nd tx
        test_scenario::next_tx(&mut scenario, @0x5);
        print_rand(15, 99, test_scenario::ctx(&mut scenario));

        // 3rd tx
        test_scenario::next_tx(&mut scenario, @0x5);
        let r1 = print_rand(99, 1000000, test_scenario::ctx(&mut scenario));

        // 4th tx: identical range as above tx, but different outcome
        test_scenario::next_tx(&mut scenario, @0x5);
        let r2 = print_rand(99, 1000000, test_scenario::ctx(&mut scenario));
        assert!(r1 != r2, EONE_IN_A_MILLION_ERROR);

        // 5th tx: 100 rands in the same tx
        test_scenario::next_tx(&mut scenario, @0x5);
        let (i, clock) = (0, clock::create_for_testing(test_scenario::ctx(&mut scenario)));
        while (i < 100) {
            clock::increment_for_testing(&mut clock, 1);

            print_rand(0, 100, test_scenario::ctx(&mut scenario));
            // std::debug::print(&utf8(b"-----------"));
            print_rand_with_clock(0, 100, &clock, test_scenario::ctx(&mut scenario));
            i = i + 1;
        };

        clock::destroy_for_testing(clock);
        test_scenario::end(scenario);
    }
}